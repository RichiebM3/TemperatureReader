//Richard A Bruce
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "tm4c123gh6pm.h"

#define clear_display 0x01
#define return_cursor 0x02
#define move_cursor_right 0x06
#define move_cursor_left 0x08
#define display_right 0x1C
#define display_left 0x18
#define cursor_blink 0x0F
#define cursor_off 0x0C
#define cursor_on 0x0E
#define set_4bit 0x28
#define set_8bit 0x38
#define entry_mode 0x06
#define func_8bit 0x0x32
#define set5x7font 0x20
#define firstRow 0x80
#define secondRow 0xC0

void delay_ms(int n);
void delay_us(int n);
void LCD_init(void);
void LCD_Cmd(unsigned char cmd);
void LCD_write_char(unsigned char data);
void LCD_write_nibble(unsigned char data, unsigned char cmd);
void LCD_string(char *str);
void Timer0A_usd(void);
void Timer1A_msd(void);
void ADC_Init(void);
void get_temperature(void);
void Timer2A_init(void);
//BLUTOOTH
void HC05_Init(void);
void write_string(char *str);
void blueTooth_Write(unsigned char data);
void Bluetooth_init(void);
void test_bluetooth(void);
char blueTooth_Read(void);


// INTERRUPT
void DisableInterrupts(void);
void EnableInterrupts(void);
void WaitForInterrupt(void);
void TIMER2A_Handler(void);

// GLOBAL VARIABLES
int temperature=0;
char snum[16];
char display_buffer[64];
int current_temp = 0;
int prev_temp = 0;
int temp_change = 0;


// LCD SCREEN FUNCTIONS
void LCD_Cmd(unsigned char cmd){
		LCD_write_nibble(cmd &0xF0, 0);  // 0=command, RS =0
		LCD_write_nibble(cmd << 4, 0);
		
		// if lowest 4-bit data takes more time
		if(cmd < 4)
				delay_ms(2);
		else 
				delay_us(40);
}

void LCD_write_nibble(unsigned char data, unsigned char cmd){
		data = data & 0xF0;	// D4-7 data/command
		cmd = cmd & 0x0F;	// D0-3 control , RS =0 for control, RS =1 for data
		GPIO_PORTB_DATA_R = data | cmd | 0x04;  // send data and command to LCD
		//GPIO_PORTB_DATA_R |= 0x04;  // Enable pin PB2
		GPIO_PORTB_DATA_R |= data; // Ensuring data
		GPIO_PORTB_DATA_R = 0; // Done writing to LCD
}

void LCD_write_char(unsigned char data){
		LCD_write_nibble(data &0xF0, 0x01);
		LCD_write_nibble(data << 4, 0x01);
		delay_us(40);
}

void LCD_string(char *str){
		int i;
		for(i=0; str[i]!=0; i++){
				LCD_write_char(str[i]);
		}
	
}
//BLUETOOTH FUNCTIONS
void Bluetooth_init(void){
    SYSCTL_RCGCGPIO_R |= 0x10;        // Enable clock to PORTE
    while((SYSCTL_PRGPIO_R & 0x10) == 0){};
    
    GPIO_PORTE_AMSEL_R &= ~0x30;      // Disable analog function on PE4,PE5
    GPIO_PORTE_AFSEL_R |= 0x30;       // Enable alternate function
    GPIO_PORTE_PCTL_R &= ~0x00FF0000;
    GPIO_PORTE_PCTL_R |= 0x00110000;  // Configure PE4,PE5 for UART
    GPIO_PORTE_DEN_R |= 0x30;         // Enable digital I/O on PE4,PE5
    GPIO_PORTE_DIR_R |= 0x20;         // Set PE5 as output (TX)
    GPIO_PORTE_DIR_R &= ~0x10;        // Set PE4 as input (RX)
}

void HC05_Init(void){
    SYSCTL_RCGCUART_R |= 0x20;        // Enable UART5 clock
    while((SYSCTL_PRUART_R & 0x20) == 0){};
    
    UART5_CTL_R &= ~0x01;             // Disable UART5
    
    // For 9600 baud rate with 50MHz clock:
    // BRD = 50MHz/(16 * 9600) = 325.52083
    // IBRD = 325
    // FBRD = 0.52083 * 64 = 33.33 ˜ 33
    UART5_IBRD_R = 325;               
    UART5_FBRD_R = 33;
    
    UART5_LCRH_R = 0x60;              // 8-bit, no parity, one stop bit
    UART5_CC_R = 0x0;                 // Use system clock
    UART5_CTL_R |= 0x301;             // Enable UART5, TXE, RXE
}

void blueTooth_Write(unsigned char data){
    while((UART5_FR_R & (1<<5)) != 0); // Wait until Tx buffer not full
    UART5_DR_R = data;
    delay_ms(1);  // Add small delay between characters
}

void write_string(char *str){
    int i;
    for (i = 0; i < strlen(str); i++){
        blueTooth_Write(str[i]);
    }
    // Add carriage return and line feed
    blueTooth_Write('\r');
    blueTooth_Write('\n');
    delay_ms(10);  // Delay between messages
}
char blueTooth_Read(void){
    uint32_t timeout = 1000000;
    char received;
    
    // Wait for data with timeout
    while((UART5_FR_R & (1<<4)) != 0 && timeout > 0) { 
        timeout--;
    }
    
    if(timeout == 0) {
        write_string("ERROR: Bluetooth read timeout");
        return 0;
    }
    
    // Read the data
    received = (unsigned char)(UART5_DR_R & 0xFF);
    
    // Echo back what was received
    sprintf(display_buffer, "Received: %c (0x%02X)", received, received);
    write_string(display_buffer);
    
    return received;
}
void test_bluetooth(void) {
    write_string("Testing Bluetooth Communication");
    write_string("If you can read this, Bluetooth is working");
    
    // Send some test values
    for(int i = 0; i < 5; i++) {
        sprintf(display_buffer, "Test message %d", i);
        write_string(display_buffer);
        delay_ms(500);
    }
}

//TIME FUNCTIONS
void delay_ms(int n){
		Timer1A_msd();
		int i;
	
    for(i = 0; i < n; i++) { 
			while ((TIMER1_RIS_R & 0x01) == 0);      /* wait for TimerA timeout flag */
        TIMER1_ICR_R = 0x01;      /* clear the TimerA timeout flag */
    }
}

void delay_us(int n){
		Timer0A_usd();
		int i;
	
    for(i = 0; i < n; i++) { 
			while ((TIMER0_RIS_R & 0x01) == 0);      /* wait for TimerA timeout flag */
        TIMER0_ICR_R = 0x01;      /* clear the TimerA timeout flag */
    }
}

void get_temperature(void){
		ADC0_PSSI_R |= 0x08;
		while((ADC0_RIS_R & 8)== 0x0);
		//	timer0A_delayMs(1000);
		//	temperature = ((ADC0_SSFIFO3_R &0xFFF)-500)/10; //
		//temperature = ((ADC0_SSFIFO3_R &0xFFF)*190)/4095;
		temperature =((ADC0_SSFIFO3_R&0xFFF - 620)*100)/1241;
		//temperature =(((ADC0_SSFIFO3_R &0xFFF) * 600/2) / 4096); // 10mV/oC// 190 = range of temp -40 to 150, 2 is voltage range 0.1-2v, 4096 is 12 bit sampling
		//	if(((ADC0_SSFIFO3_R & 0xFFF) < 2300) ){  // && ((ADC0_SSFIFO3_R & 0xFFF) > 700)
		//		temperature = ((ADC0_SSFIFO3_R & 0xFFF)* 165/2300) - 75; //
		//	temperature =(((ADC0_SSFIFO3_R &0xFFF) * 190/2) / 4096); // 190 = range of temp -40 to 150, 2 is voltage range 0.1-2v, 4096 is 12 bit sampling
		//	}
		delay_us(100);
		//if((ADC0_SSFIFO3_R & 0xFFF) > 2300){
		//		delay_us(1000);
		//}
		
		ADC0_ISC_R |= 0x8; 
	
}

int main(void){
    // Initialize peripherals
    LCD_init();
    Timer0A_usd();
    Timer1A_msd();
    ADC_Init();
    Bluetooth_init();
    HC05_Init();
    
    // Enable interrupts
    EnableInterrupts();
    
    // Initial display setup
    LCD_Cmd(clear_display);
    LCD_Cmd(firstRow);
    LCD_string("Initializing...");
    delay_ms(1000);
    
    // Get initial temperature
    get_temperature();
    current_temp = temperature;
    prev_temp = current_temp;
    
    // Initialize Timer2A for 30-second intervals
    Timer2A_init();
    
    // Send initial readings
    sprintf(display_buffer, "System Ready\r\nInitial Temp: %d°C\r\n", current_temp);
    write_string(display_buffer);
    
    while(1){
        // Check for Bluetooth commands
        if(!(UART5_FR_R & (1<<4))) {
            char c = blueTooth_Read();
            if(c == 'T' || c == 't') {
                sprintf(display_buffer, "Current Temperature: %d°C\r\nLast change: %+d°C\r\n", 
                        current_temp, temp_change);
                write_string(display_buffer);
            }
        }
        
        WaitForInterrupt();
    }
}

void TIMER2A_Handler(void){
    if(TIMER2_MIS_R & 0x01){
        // Save previous temperature
        prev_temp = current_temp;
        
        // Get new temperature
        get_temperature();
        current_temp = temperature;
        
        // Calculate temperature change
        temp_change = current_temp - prev_temp;
        
        // Update LCD
        LCD_Cmd(clear_display);
        LCD_Cmd(firstRow);
        LCD_string("Cur. Temp.: ");
        sprintf(snum, "%d", current_temp);
        LCD_string(snum);
        LCD_write_char(0xDF); // Degree symbol
        LCD_write_char('C');
        
        LCD_Cmd(secondRow);
        LCD_string("Change: ");
        if(temp_change >= 0) {
            LCD_write_char('+');
            sprintf(snum, "%d", temp_change);
        } else {
            sprintf(snum, "%d", temp_change);
        }
        LCD_string(snum);
        LCD_write_char(0xDF);
        LCD_write_char('C');
        
        // Send to Bluetooth
        sprintf(display_buffer, "Cur. Temp.: %d°C\r\nTemp. change: %+d°C\r\n", 
                current_temp, temp_change);
        write_string(display_buffer);
        
        // Clear interrupt flag
        TIMER2_ICR_R = 0x01;
    }
}

void LCD_init(void){
		SYSCTL_RCGC2_R |= 0x02;
		GPIO_PORTB_DIR_R = 0xFF;
		GPIO_PORTB_DEN_R = 0xFF;
		
		LCD_Cmd(0x20);  // set 5x7 font
		LCD_Cmd(0x28);	// set 4-bit
		LCD_Cmd(0x06);	// move cursor right
		LCD_Cmd(0x01);	// clear display
		LCD_Cmd(0x0F);	// cursor blink
}

void ADC_Init(void){
		SYSCTL_RCGC2_R |= 0x08;
		SYSCTL_RCGCADC_R |= 0x01;   // Enable clock ADC0
	/* initialize PD0 for AIN0 input */
 // GPIO_PORTD_CR_R = 0x02;
		GPIO_PORTD_AFSEL_R |= 0x02;        /* enable alternate function */
		GPIO_PORTD_DEN_R &= ~0x2;         /* disable digital function */
  //GPIO_PORTD_DIR_R = ~0x02;
		GPIO_PORTD_AMSEL_R |= 0x02;        /* enable analog function */
	
	 /* initialize ADC0 */
		ADC0_ACTSS_R &= ~0x8;             /* disable SS3 during configuration */
		ADC0_EMUX_R &= ~0xF000;         /* software trigger conversion */
		ADC0_SSMUX3_R = 6;              /* get input from channel 6  */
		ADC0_SSCTL3_R |= 0x6;             /* take one sample at a time, set flag at 1st sample */
		ADC0_ACTSS_R |= 0x8;              /* enable ADC0 sequencer 3 */
		ADC0_PC_R = 0x01;
}

void Timer0A_usd(void){
	 SYSCTL_RCGCTIMER_R |= 0x01;     /* enable clock to Timer0, Timer1, Timer2 */
    
		TIMER0_CTL_R = 0x00;            /* disable Timer before initialization */
    TIMER0_CFG_R = 0x00;         /* 32-bit option */
    TIMER0_TAMR_R = 0x02;        /* periodic mode and down-counter */
    TIMER0_TAILR_R = 50 - 1;  /* Timer A interval load value register */
    TIMER0_ICR_R = 0x1;          /* clear the TimerA timeout flag*/
    TIMER0_CTL_R |= 0x01;        /* enable Timer A after initialization */
		TIMER0_TAPR_R = 1-1;					// Prescalar value.. Can extend the cycle time max 256 times
}

void Timer1A_msd(void){
	 SYSCTL_RCGCTIMER_R |= 0x03;     /* enable clock to Timer0, Timer1 */
    TIMER1_CTL_R = 0x00;            /* disable Timer before initialization */
    TIMER1_CFG_R = 0x00;         /* 32-bit option */
    TIMER1_TAMR_R = 0x02;        /* periodic mode and down-counter */
    TIMER1_TAILR_R = 50000 - 1;  /* 10msec.. Timer A interval load value register */
    TIMER1_ICR_R = 0x1;          /* clear the TimerA timeout flag*/
    TIMER1_IMR_R |= 0x1;
		TIMER1_TAPR_R = 1-1;					// Prescalar value.. Can extend the cycle time max 256 times
		TIMER1_CTL_R |= 0x021;        /* enable Timer A after initialization */
		// NVIC_EN0_R |= 0x80000;         // Enable Timer0A interrupt
		// NVIC_PRI4_R = (NVIC_P RI4_R&0x00FFFFFF) | 0x80000000;
}

void Timer2A_init(void){
		SYSCTL_RCGCTIMER_R |= 0x04;     /* enable clock to Timer0, Timer1 */
    TIMER2_CTL_R = 0x00;            /* disable Timer before initialization */
    TIMER2_CFG_R = 0x00;         /* 32-bit option */
    TIMER2_TAMR_R = 0x02;        /* periodic mode and down-counter */
    TIMER2_TAILR_R = 0xFFFFFFFF ;  /* 10msec.. Timer A interval load value register */
    TIMER2_ICR_R = 0x1;          /* clear the TimerA timeout flag*/
    TIMER2_IMR_R |= 0x1;
		TIMER2_TAPR_R = 14;					// Prescalar value.. Can extend the cycle time max 256 times
		TIMER2_CTL_R |= 0x01;        /* enable Timer A after initialization */
		NVIC_PRI5_R = (NVIC_PRI5_R&0x00FFFFFF) | 0x80000000; // priority 4
		NVIC_EN0_R |= 0x800000;         // Enable Timer2A interrupt
	
}


/*********** DisableInterrupts ***************
*
* disable interrupts
*
* inputs:  none
* outputs: none
*/

void DisableInterrupts(void)
{
    __asm ("    CPSID  I\n");
}

/*********** EnableInterrupts ***************
*
* emable interrupts
*
* inputs:  none
* outputs: none
*/

void EnableInterrupts(void)
{
    __asm  ("    CPSIE  I\n");
}

/*********** WaitForInterrupt ************************
*
* go to low power mode while waiting for the next interrupt
*
* inputs:  none
* outputs: none
*/

void WaitForInterrupt(void)
{
    __asm  ("    WFI\n");
//GPIOPortF_Handler();
}
